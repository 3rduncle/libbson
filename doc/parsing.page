<page xmlns="http://projectmallard.org/1.0/"
      type="topic"
      id="parsing">
  <info><link type="guide" xref="index#intro"/></info>
  <title>Parsing and Iterating BSON Documents</title>

  <p>BSON documents are lazily parsed as necessary. To begin parsing a BSON document, use one of the provided Libbson functions to create a new <link xref="bson_t">bson_t</link> from existing data such as <link xref="bson_new_from_data">bson_new_from_data()</link>. This will make a copy of the data so that additional mutations may occur to the BSON document.</p>
  <note style="tip"><p>If you only want to parse a BSON document and have no need to mutate it, you may use <link xref="bson_init_static">bson_init_static()</link> to avoid making a copy of the data.</p></note>

  <example><code mime="text/x-csrc"><![CDATA[bson_t *b;

b = bson_new_from_data (my_data, my_data_len);
if (!b) {
   fprintf (stderr, "The specified length embedded in <my_data> did not match <my_data_len>\n");
   return;
}

bson_destroy (b);]]></code></example>

  <p>Only two checks are performed when creating a new <link xref="bson_t">bson_t</link> from an existing buffer. First, the document must begin with the buffer lenght, matching what was expected by the caller. Second, the document must end with the expected trailing <code>\0</code> byte.</p>
  <p>To parse the document further we use a <link xref="bson_iter_t">bson_iter_t</link> to iterate the elements within the document. Let's print all of the field names in the document.</p>

  <example><code mime="text/x-csrc"><![CDATA[bson_t *b;
bson_iter_t iter;

if ((b = bson_new_from_data (my_data, my_data_len))) {
   if (bson_iter_init (&iter, b)) {
      while (bson_iter_next (&iter)) {
         printf ("Found element key: \"%s\"\n", bson_iter_key (&iter));
      }
   }
   bson_destroy (b);
}]]></code></example>

  <p>Converting a document to JSON uses a <link xref="bson_iter_t">bson_iter_t</link> and <link xref="bson_visitor_t">bson_visitor_t</link> to iterate all fields of a BSON document recursively and generate a UTF-8 encoded JSON string.</p>

  <example><code mime="text/x-csrc"><![CDATA[bson_t *b;
char *json;

if ((b = bson_new_from_data (my_data, my_data_len))) {
   if ((str = bson_as_json (b, NULL))) {
      printf ("%s\n", str);
      bson_free (str);
   }
   bson_destroy (b);
}]]></code></example>

  <section id="validating">
    <title>Validating a BSON Document</title>
    <p>If all you want to do is validate that a BSON document is valid, you can use <link xref="bson_validate">bson_validate()</link>.</p>
    <example><code mime="text/x-csrc"><![CDATA[size_t err_offset;

if (!bson_validate (doc, BSON_VALIDATE_NONE, &err_offset)) {
   fprintf (stderr, "The document failed to validate at offset: %u\n",
            (unsigned)err_offset);
}]]></code></example>
    <p>See the <link xref="bson_validate">bson_validate()</link> documentation for more information and examples.</p>
  </section>

</page>
